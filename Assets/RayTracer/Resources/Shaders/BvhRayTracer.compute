#pragma kernel BvhRayTracer

#include "Math.cginc"
#include "Bvh.cginc"

float3 _light;
float4x4 _inverseCameraMatrix;
float3 _origin;
StructuredBuffer<Bvh::Node> _nodes;
StructuredBuffer<IndexedTriangle> _triangles;
StructuredBuffer<float4> _vertices;
RWTexture2D<float4> _result;

#define STACK_SIZE 64

static const int _entrypointSentinel = 2147483647;

struct FloatMinMax
{
	float min;
	float max;
};

float max4(float a, float b, float c, float d)
{
	return max(a, max(b, max(c, d)));
}

float min4(float a, float b, float c, float d)
{
	return min(a, min(b, min(c, d)));
}

// https://tavianator.com/fast-branchless-raybounding-box-intersections/
FloatMinMax IntersectAabb(Bvh::AABB b, Ray r)
{
	float3 invD = 1.0 / r.direction;
	float3 OoD = r.origin * invD;

	float x0 = b.min.x * invD.x - OoD.x;
	float y0 = b.min.y * invD.y - OoD.y;
	float z0 = b.min.z * invD.z - OoD.z;
	float x1 = b.max.x * invD.x - OoD.x;
	float y1 = b.max.y * invD.y - OoD.y;
	float z1 = b.max.z * invD.z - OoD.z;
 
 	FloatMinMax t;
    t.min = max4(0.01, min(x0, x1), min(y0, y1), min(z0, z1));
    t.max = min4(100000, max(x0, x1), max(y0, y1), max(z0, z1));
 
    return t;
}

[numthreads(8, 8, 1)]
void BvhRayTracer(uint3 id : SV_DispatchThreadID)
{
	Ray r = CameraRay(_inverseCameraMatrix, _origin, id.xy);
	int traversalStack[STACK_SIZE];
	bool isLeafStack[STACK_SIZE];
	traversalStack[0] = _entrypointSentinel;
	int nodeIndex = 0;
	int nodeIsLeaf = false;
	int stackIndex = 0;

	// float3 idir = 1.0 / r.direction;
	float3 coordinates = float3(1, 0, 1);
	float t = 100000;

	int iteration = 0;

	while (nodeIndex != _entrypointSentinel)
	{
		while (!nodeIsLeaf && nodeIndex != _entrypointSentinel)
		{
			Bvh::Node node = _nodes[nodeIndex];
			FloatMinMax tLeft = IntersectAabb(node.leftBounds, r);
			FloatMinMax tRight = IntersectAabb(node.rightBounds, r);
			bool traverseLeft = tLeft.min <= tLeft.max;
			bool traverseRight = tRight.min <= tRight.max;

			nodeIndex = node.left;
			nodeIsLeaf = node.isLeftLeaf;

			if (traverseLeft != traverseRight)
			{
				// If only a single child was intersected we simply go to that one
				if (traverseRight)
				{
					nodeIndex = node.right;
					nodeIsLeaf = node.isRightLeaf;
				}
			}
			else
			{
				if (!traverseLeft)
				{
					// If neither child was intersected we pop the stack
					nodeIndex = traversalStack[stackIndex];
					nodeIsLeaf = isLeafStack[stackIndex];
					stackIndex--;
				}
				else
				{
					// If both children were intersected we push one onto the stack
					int postponeIndex;
					bool postponeIsLeaf;
					if (tRight.min < tLeft.min)
					{
						nodeIndex = node.right;
						nodeIsLeaf = node.isRightLeaf;
						postponeIndex = node.left;
						postponeIsLeaf = node.isLeftLeaf;
					}
					else
					{
						nodeIndex = node.left;
						nodeIsLeaf = node.isLeftLeaf;
						postponeIndex = node.right;
						postponeIsLeaf = node.isRightLeaf;
					}
					stackIndex++;
					traversalStack[stackIndex] = postponeIndex;
					isLeafStack[stackIndex] = postponeIsLeaf;
				}
			}
		}

		if (nodeIsLeaf)
		{
			int leafIndex = nodeIndex;
			// coordinates = float3(0, 0, 1);
			// nodeIndex = _entrypointSentinel;
			// break;

			IndexedTriangle indices = _triangles[leafIndex];
			Triangle tri = MakeTriangle(_vertices[indices.v1].xyz, _vertices[indices.v2].xyz, _vertices[indices.v3].xyz);

			// intersect triangle
			float3 candidateCoordinates;
			float candidate_t = IntersectTriangle(tri, r, candidateCoordinates);
			if (candidate_t > 0.01 && candidate_t < t)
			{
				coordinates = candidateCoordinates;
				t = candidate_t;
			}

			nodeIndex = traversalStack[stackIndex];
			nodeIsLeaf = isLeafStack[stackIndex];
			stackIndex--;
		}
		iteration++;
	}

	_result[id.xy] = float4(coordinates, 1);
}